# 211103
## 공부 (1강~5강)

# 06 데이터 타입

- 자바스크립트의 모든 값은 데이터 타입을 갖는다.
- 총 7개 타입을 제공한다. (ES6)

    ![Untitled (21)](https://user-images.githubusercontent.com/88661435/140082512-a4308589-2592-44f9-8557-a1d7abc7da2d.png)


### 숫자 타입

- 자바스크립트는 하나의 숫자 타입만 존재한다.
- ECMAScript 사양에 따르면 숫자 타입의 값(정수, 실수, 2진수, 8진수, 16진수 리터럴)은 모두 배정밀도 64비트 부동소수점 형식을 따른다.
즉, **모든 숫자를 실수로 처리**하며, 정수만 표현하기 위한 데이터 타입이 별도로 존재하지 않는다.
- 표현은 모두 10진수로 해석된다.
- 추가적으로 세 가지 특별한 값도 표현할 수 있다.
    - Infinity : 양의 무한대
    - -Infinity : 음의 무한대
    - NaN : 산수 연산 불가(not-a-number) ⇒ 값이 아닌 식별자로 해석한다.
    

### 문자열 타입

- 텍스트를 나타내는데 사용하며, 0개 이상의 16비트 유니코드 문자(UTF-8)의 집합
- 자바스크립트의 문자열은 원시타입이며 변경이 불가능한 값이다.

### 템블릿 리터럴

- ES6부터 템플릿 리터럴이라는 새로운 문자열 표기법이 도입되었다.
- 멀티라인, 표현식 삽입, 태그드 템플릿 등을 제공한다.
- 백틱(``) 을 사용해 표현한다.

![Untitled (22)](https://user-images.githubusercontent.com/88661435/140082564-f552626f-6833-4727-bc17-afc1781188f3.png)

- 표현식 삽입
    - 표현식을 삽입하려면 `${ }` 으로 표현식을 감싼다. 이때 표현식의 평가 결과가 문자열이 아니더라도 문자열로 타입이 강제로 변환되어 삽입된다.
    - 표현식 삽입은 반드시 템플릿 리터럴 내에서 사용해야 한다. (아닌 경우 문자열로 취급됨)

### 불리언 타입

- 참, 거짓을 나타내는 true와 false

### undefined 타입

- undefined 타입의 값은 undefined가 유일하다.
- var 키워드로 선언한 변수는 처음 할당이 이뤄질 때까지 빈 상태로 있지 않고 자바스크립트 엔진이 암묵적으로 undefined로 초기화한다. (쓰레기 값)
- 변수에 값이 없다는 것을 명시하고 싶을 때는 undefined 가 아닌 null을 할당한다.

### null 타입

- null 타입의 값은 null이 유일하다.
- 자바스크립트는 대소문자를 구별하므로, null은 Null, NULL 등과 다르다.

### 심벌 타입

- ES6에서 추가된 7번째 타입으로, 변경 불가능한 원시 타입의 값이다.
- 다른 값과 중복되지 않는 유일무이한 값으로, 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용한다.
- symbol 함수를 호출해 생성한다. 이때 생성된 심벌 값은 외부에 노출되지 않으며, 다른 값과 절대 중복되지 않는 유일무이한 값이다.

```jsx
// 심벌 값 생성
var key = Symbol('key');
console.log(typeof key); // symbol

// 객체 생성
var obj = {};

// 이름이 충돌할 위험이 없는 유일무이한 값인 심벌을 프로퍼티 키로 사용하기
obj[key] = 'value';
console.log(obj[key]); // value
```

### 객체 타입

- 자바스크립트를 이루고 있는 거의 모든 것이 객체이다.

### 데이터 타입의 필요성

1. 데이터 타입에 의한 메모리 공간의 확보와 참조
    - 값은 메모리에 저장하고 참조할 수 있어야하는데, 값을 저장하려면 먼저 확보해야 할 메모리의 공간의 크기를 결정해야 한다. 즉, 몇 바이트의 메모리 공간을 사용해야 낭비 없이 값을 저장할 수 있는지 알아야 한다.
    - 예를 들어 var score = 100; 이라고 선언하면, 컴퓨터는 숫자 100을 저장하기 위해 메모리 공간을 확보한 다음, 확보된 메모리에 숫자값 100을 2진수로 변환하여 저장한다. 이 같은 처리를 하려면 숫자 값을 저장할 때 확보해야 할 메모리 공간의 크기를 알아야 한다.
    - 그 이유는 자바스크립트 엔진은 데이터 타입, 즉 값의 종류에 따라 정해진 크기의 메모리 공간을 확보하기 때문이다. 즉, 변수의 할당되는 값의 데이터 타입에 따라 확보해야 할 메모리 공간의 크기가 결정된다.
    - 값을 참조하는 경우, 숫자 값 100이 저장되어 있는 메모리 공간의 선두 메모리셀의 주소를 찾아갈 수 있다.
    이때 값을 참조하려면 한 번에 읽어 들여야 할 메모리 공간의 크기, 즉 메모리 셀의 개수(바이트 수)를 알아야 한다.
2. 데이터 타입에 의한 값의 해석
    - 메모리에서 읽어 들인 2진수를 어떻게 해석할까? 모든 값은 데이터 타입을 가지며, 메모리에 2진수(비트의 나열)로 저장된다. 메모리에 저장된 값은 데이터타입에 따라 다르게 해석될 수 있다.
3. 따라서 아래와 같은 이유때문에 데이터 타입의 필요성이 존재한다.
    - 값을 저장할 때 확보해야 하는 **메모리 공간의 크기를 결정**하기 위해
    - 값을 참조할 때 한꺼번에 읽어들여야 할 **메모리 공간의 크기를 결정**하기 위해
    - 메모리에서 읽어들인 **2진수를 어떻게 해석할지** 결정하기 위해

### 동적 타이핑

- C나 자바 같은 정적 타입 언어는 변수를 선언할 때 변수에 할당할 수 있는 값의 종류(데이터 타입)을 사전에 선언해야한다. ⇒ 명시적 타입 선언
명시적 타입은 변수의 타입을 변경할 수 없고, 변수에 선언한 타입에 맞는 값만 할당할 수 있다.
그리고 컴파일 시점에 타입 체크를 수행한다. 그후 체크를 통과하지 못하면 에러를 발생시키고 프로그램의 실행 자체를 막는다. 이를 통해 타입의 일관성을 강제하여 더욱 안정적인 코드의 구현을 통해 런타임에 발생하는 에러를 줄인다.
- 이와 반대로 자바스크립트는 var, let, const 키워드를 이용해 변수를 선언할 뿐이며, 어떤 데이터 값이라도 자유롭게 할당이 가능하다. 따라서 자바스크립트에서는 값을 할당하는 시점에 변수의 타입이 동적으로 결정된다.
- 자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론)된다. 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다 ⇒ 동적 타이핑 / 동적 타입 언어

### 동적 타입 언어와 변수

- 변수의 타입이 고정되어 있지 않고 동적으로 변하는 동적 타입 언어의 변수는 값을 확인하기 전에는 타입을 확실할 수 없다.
- 더욱이 개발자와의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 자동으로 변환되기도 한다. 결국 동적 타입 언어는 유연성은 높지만 신뢰성은 떨어진다.
- 변수 사용시 주의점
    - 변수는 꼭 필요한 경우에 한해 제한적으로 사용한다.
    - 변수의 유효 범위(스코프)는 최대한 좁게 만들어 변수의 부작용을 억제한다.
    - 전역 변수는 최대한 사용하지 않도록 한다. 프로그램의 복잡성을 증가시키고 처리 흐름을 추적하기 어렵게 만들고 오류가 발생할 경우 오류의 원인을 특정하기 어렵게 만든다.
    - 변수보다는 상수를 사용해 값의 변경을 억제한다.
    - 변수 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍한다.
- 가독성이 좋은 코드가 좋은 코드다.

# 07 연산자

- 연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만든다.
- 이때 연산의 대상을 피연산자라하며, 피연산자는 값으로 평가될 수 있는 표현식이어야 한다.

### 산술 연산자

- 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다. 산술 연산이 불가능한 경우, NaN 반환
1. 이항 산술 연산자
    - 2개의 피연산자를 산술 연산하여 숫자 값을 만든다.
    
    ```jsx
    5 + 2; // 7
    5 % 2; // 1
    ...
    ```
    
2. 단항 산술 연산자
    - 1개의 피연산자를 산술 연산하여 숫자 값을 만든다.
        
        ```jsx
        let x = 1;
        x++;
        ```
        
    - 증가/감소 연산자는 위치에 의미가 있다.
        - 피연산자 앞에 위치한 전위 증가/감소 연산자는 먼저 피연산자의 값을 증가/감소 시킨 후 다른 연산자를 수행한다.
        - 피연산자 뒤에 위치한 전위 증가/감소 연산자는 먼저 다른 연산을 수행한 후, 피연산자의 값을 증가/감소 시킨다.
        
        ```jsx
        var x = 5, result;
        
        result = x++;
        console.log(result, x); // 5, 6
        
        result = ++x;
        console.log(result, x); // 7, 7
        
        result = x--;
        console.log(result, x); // 7, 6
        
        result = --x;
        console.log(result, x); // 5, 5
        ```
        
    

### 문자열 연결 연산자

- + 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.

### 할당 연산자

- 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다. 할당 연산자는 좌항의 변수에 값을 할당하므로 변수 값이 변하는 부수효과가 있다.
- 할당문은 표현식인 문이다.
    
    ```jsx
    var x;
    console.log(x = 10); // 10
    ```
    
- 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가된다.

### 비교 연산자

- 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환

1. 동등/일치 비교 연산자
    - 동등 비교 연산자는 느슨한 비교, 일치 비교 연산자는 엄격한 비교를 한다.
    
        ![Untitled (23)](https://user-images.githubusercontent.com/88661435/140082647-72b4fcb0-d0f2-47b1-998c-8b723910505d.png)
    
    - 동등 비교(==) 연산자는 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교한다.
    - 일치 비교(===) 연산자는 좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한하여 true를 반환한다. ⇒ 암묵적 타입 변환을 하지 않고 값을 비교한다.
        - 일치 비교 연산자에서 주의할 것은 NaN이다.
            
            ```jsx
            NaN === NaN; // false -> NaN은 자신과 일치하지 않는 유일한 값
            ```
            
        - 따라서 NaN인지 조사하려면 inNaN 함수를 사용한다.

### 삼항 조건 연산자

- 첫 번째 피연산자가 true로 평가 되면 두 번째 피연산자를 반환하고, 첫 번째 피 연산자가 false로 평가되면 세 번째 피 연산자를 반환한다.

```jsx
var result = score >= 60 ? 'pass' : 'fail';
```

### 쉼표 연산자

- 쉼표 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다.
    
    ```jsx
    var x, y, z;
    x = 1, y = 2, z = 3; // 3
    ```
    

### typeof 연산자

- 피연산자의 데이터 타입을 문자열로 반환한다
- string, number, boolean, undefined, symbol, object, function 중 1개 반환
- null을 반환하는 경우는 없으며, null 대신 object를 반환한다. (자바 스크립트의 첫 번째 버전의 버그지만, 기존 코드에 영향을 줄 수 있어 아직까지 수정되지 못하고 있다고 한다.)
    - 따라서 값이 null인지 확인할 때는 일치 연산자(===)를 이용할 것!
- 선언하지 않은 식별자를 typeof 연산자로 연산해 보면 ReferenceError가 아닌 undefined를 반환하니 이것도 주의하기!

### 지수 연산자

- ES7에서 도입된 지수 연산자는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 값을 반환한다.
- 지수 연산자가 도입되기 이전에는 Math.pos 메서드를 이용했다.

### 연산자의 부수 효과

부수효과가 있는 연산자는 할당 연산자(=), 증가/감소 연산자(++/—), delete 연산자다.

### 연산자 우선순위

![Untitled (24)](https://user-images.githubusercontent.com/88661435/140082720-bf18dc69-0185-4b24-a1e6-10a354e4023e.png)

![Untitled (25)](https://user-images.githubusercontent.com/88661435/140082731-dd9baf88-9b10-48af-9655-fa0589d6e939.png)


# 08 제어문

- 조건에 따라 코드 블록을 실행(반복문)하거나 반복 실행(조건문)할 때 사용

### 블록문

- 0개 이상의 문을 중괄호로 묶은 것
- 자바스크립트는 블록문을 하나의 실행 단위로 취급

### 조건문

- 주어진 조건식의 평가 결과에 따라 코드 블록(블록문)의 실행을 결정한다.
- 불리언 값으로 평가될 수 있는 표현식이다.
- if ... else 문
- switch 문
    - break 문이 없다면 case 문의 표현식과 일치하지 않더라도 실행 흐름이 다음 case문으로 연이어 이동하는 폴 스루가 발생한다. (case 값이 일치함에도 switch문을 탈출하지 않는 것)
    - 따라서 올바른 switch문을 잘 사용해야 한다. (break 문 필수!)
    - default 문은 선택이지만, switch문의 맨 마지막에 위치하므로 default 문의 실행이 종료되면 switch문을 빠져나가므로 별도로 break문이 필요하지 않음

### 반복문

- for, while, do...while, forEach(배열 순회), for...in(객체의 프로퍼티 열거할 때 사용), for...of(ES6에서 도입된 이터러블을 순회할 수 있음)

### continue문

- 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동시킨다.
- break 문처럼 반복문을 탈출하지는 않는다.

# 09 타입 변환과 단축 평가

### 타입 변환

- 개발자가 의도적으로 값의 타입을 변환하는 것을 **명시적 타입 변환** 또는 **타입 캐스팅**이라 한다.
- 타입변환(or 타입 강제 변환) : 개발자의 의도와는 상관없이 표현식을 평가하는 중 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되는 것
    
    ```jsx
    var x = 10;
    
    // 암묵적 타입 변환
    // 문자열 연결 연산자는 숫자 타입 x의 값을 바탕으로 새로운 문자열을 생성한다.
    var str = x + '';
    console.log(typeof str, str); // string, 10
    
    // x 변수의 값이 변경된 것은 아님
    console.log(typeof x, x); //number, 10
    ```
    

### 옵셔널 체이닝 연산자

ES11(ECMAScript2020)에서 도입된 옵셔널 체이닝 연산자 `?.`는 좌항의 피연선자가 null 또는 undefined인 경우 undefined를 반환하고, 그렇지 않으면 우항의 프로퍼티 참조를 이어간다.

```jsx
var elem = null;

// elem이 null 또는 undefined이면 undefined를 반환하고, 
// 그렇지 않으면 우항의 프로퍼티 참조를 이어간다.
var value = elem?.value;
console.log(value); // undefined
```

- 객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 참조할 때 유용하다.
- 옵셔널 체이닝 연산자를 이용하면, 이전에 논리 연산자 && 를 사용하여 변수가 null 또는 undefined인지 확인했던 걸 대신하여 편리하게 사용할 수 있다.

### null 병합 연산자

ES!!(ECMAScript2020)에서 도입된 null 병합 연산자 `??` 는 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를

# 10 객체 리터럴

### 객체란?

1. 자바스크립트는 객체 기반의 프로그래밍 언어이며, 구성하는 거의 모든 것이 객체이다.
2. 원시 값을 제외한 나머지 값(함수, 배열, 정규 표현식 등)은 모두 객체다.
3. 객체타입은 다양한 타입의 값을 하나의 단위로 구성한 복합적인 자료구조다.
4. 원시 값은 변경 불가능한 값이지만, 객체 타입의 값(=객체)는 **변경 가능한 값**이다.
5. 객체는 프로퍼티와 메서드로 구성된 집합체다.
    - 프로퍼티 : 객체의 **상태**를 나타내는 값(data)
    - 메서드 : 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 **동작**
   
    ![Untitled (26)](https://user-images.githubusercontent.com/88661435/140082812-4879aa95-cf45-4ed2-bef2-baea993ac1cb.png)


### 객체 리터럴에 의한 객체 생성

C++이나 자바 같은 클래스 기반 객체지향 언어는 클래스를 사전에 정의하고 필요한 시점에 new 연산자와 함께 생성자를 호출하여 인스턴스를 생성하는 방식으로 객체를 생성한다.

하지만 자바스크립트는 프로토타입 기반 객체지향 언어로서 클래스 기반 객체지향 언어와는 달리 다양한 객체 생성 방법을 지원한다.

- 객체 리터럴, Object 생성자 함수, 생성자 함수, Object.create 메서드, 클래스(ES6)

이 중에서 가장 일반적이고 간단한 방법은 객체 리터럴을 사용하는 방법이다.

리터럴이란, 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값을 생성하는 표기법이다.

객체 리터럴의 중괄호는 코드 블록을 의미하지 않는다.

객체 리터럴 외의 객체 생성 방식은 모두 함수를 사용해 객체를 생성한다.

### 프로퍼티

객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다.

자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값으로 사용할 수 있다.

- 프로퍼티 키 : 빈 문자열을 포함하는 모든 문자열 또는 심벌 값 (식별자 역할)
- 프로퍼티 값 : 자바스크립트에서 사용할 수 있는 모든 값

### 메서드

프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메서드라 부른다.
