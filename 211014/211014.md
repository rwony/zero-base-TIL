# DFS (Depth First Search)

- 깊이 우선 탐색
- 트리나 그래프 등에서 하나의 노드를 최대한 깊게 들어가면서 완벽하게 탐색하는 기법
- 루트 노드(혹은 다른 임의의 노드)에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법이다.
- 장/단점
    - 장점 : 인접한 후보 노드만 기억하면 되므로 적은 기억공간 소요, 노드가 깊은 단계에 있을 경우 빠르게 정답 산출
    - 단점 : 선택한 경로가 답이 아닐 경우 불필요한 탐색 가능, 최단 경로를 구할 시 찾은 해가 정답이 아닐 경우 발생
- 구현 메서드(method)
    - 재귀를 이용한 탐색 : Graph._dfsRecursiveVisit()
    - 스택을 이용한 탐색 : Graph._dfsLoopVisit()
    
- dfs() : DFS 탐색
    
    ```jsx
    Graph.prototype.dfs = function(startVertex) {
      this._dfsRecursiveVisit(startVertex);
    };
    ```
    
- _dfsRecursiveVisit() : 재귀를 이용한 DFS 탐색
    
    ```jsx
    Graph.prototype._dfsRecursiveVisit = function(vertex) {
      if (this.visited[vertex]) {
        return;
      }
      this.visited[vertex] = true;
      console.log(`visit "${vertex}"`);
    
      let neighbors = this.edge[vertex];
      for (let i = 0; i < neighbors.length; i++) {
        this._dfsRecursiveVisit(neighbors[i]);
      }
    };
    ```
    
- print (출력)
    
    ```jsx
    let graph = new Graph();
    let vertices = ["A", "B", "C", "D", "E", "F", "G ", "H", "I"];
    
    for (let i = 0; i < vertices.length; i++) {
      graph.addVertex(vertices[i]);
    }
    
    graph.addEdge("A", "B");
    graph.addEdge("A", "C");
    graph.addEdge("A", "D");
    graph.addEdge("C", "G");
    graph.addEdge("D", "G");
    graph.addEdge("D", "H");
    graph.addEdge("B", "E");
    graph.addEdge("B", "F");
    graph.addEdge("E", "I");
    graph.print();
    console.log("");
    
    graph.dfs("A");
    ```
    
- dfs() : DFS 탐색
    
    ```jsx
    import { Stack } from "./stack.mjs"; 
    
    // dfs(): DFS 탐색
    Graph.prototype.dfs = function(startVertex) {
      // this._dfsRecursiveVisit(startVertex);
      this._dfsLoopVisit(startVertex);
    };
    ```
    
- _dfsLoopVisit() : 스택을 이용한 DFS 탐색
    
    ```jsx
    Graph.prototype._dfsLoopVisit = function(vertex) {
      let stack = new Stack();
      stack.push(vertex);
    
      while (!stack.isEmpty()) {
        let vertex = stack.pop();
        if (this.visited[vertex]) {
          continue;
        }
        this.visited[vertex] = true;
        console.log(`visit "${vertex}"`);
        let neighbors = this.edge[vertex];
        for (let i = neighbors.length - 1; i >= 0; i--) {
          stack.push(neighbors[i]);
        }
      }
    };
    ```
    
- print (출력)
    
    ```jsx
    let graph = new Graph();
    let vertices = ["A", "B", "C", "D", "E", "F", "G ", "H", "I"];
    
    for (let i = 0; i < vertices.length; i++) {
      graph.addVertex(vertices[i]);
    }
    graph.addEdge("A", "B");
    graph.addEdge("A", "C");
    graph.addEdge("A", "D");
    graph.addEdge("C", "G");
    graph.addEdge("D", "G");
    graph.addEdge("D", "H");
    graph.addEdge("B", "E");
    graph.addEdge("B", "F");
    graph.addEdge("E", "I");
    graph.print();
    console.log("");
    graph.dfs("A");
    ```
    

# BFS (Breadth First Search)

- 트리나 그래프 등에서 인접한 노드를 우선 방문하면서 넓게 움직이며 해를 찾는 탐색 기법
- 장/단점
    - 장점 : 최단 경로 탐색에서 구한 해가 정답임을 보장
    - 단점 : 경로가 매우 길어질 경우, 탐색 범위가 증가하면서 DFS보다 많은 기억 공간이 필요
- 구현 메서드(method)
    - 큐를 이용한 탐색 : Graph.bfs(), Graph._bfsLoopVisit()
    - 최단 경로 탐색 : Graph.shortestPath(), Graph._bfsShortestPath(), Graph._from_to_path()
    
- bfs() : BFS 탐색
    
    ```jsx
    import { Queue } from "./queue.mjs"; 
    
    // bfs(): BFS 탐색
    Graph.prototype.bfs = function(startVertex) {
      this._bfsLoopVisit(startVertex);
    };
    ```
    
- _bfsLoopVisit() : 큐를 이용한 BFS 탐색
    
    ```jsx
    Graph.prototype._bfsLoopVisit = function(vertex) {
      let queue = new Queue();
      queue.enqueue(vertex);
    
      while (!queue.isEmpty()) {
        let vertex = queue.dequeue();
        if (this.visited[vertex]) {
          continue;
        }
        this.visited[vertex] = true;
        console.log(`visit "${vertex}"`);
    
        let neighbors = this.edge[vertex];
        for (let i = 0; i < neighbors.length; i++) {
          queue.enqueue(neighbors[i]);
        }
      }
    };
    ```
    

- _bfsShortestPath() : 다른 정점 간 최단 경로 비용 산출
    
    ```jsx
    Graph.prototype._bfsShortestPath = function(vertex) {
      let queue = new Queue();
      queue.enqueue(vertex);
      let distance = {};
      let pre_visit = {};
    
      for (let vertex in this.edge) {
        distance[vertex] = 0;
        pre_visit[vertex] = null;
      }
    
      while (!queue.isEmpty()) {
        let vertex = queue.dequeue();
        this.visited[vertex] = true;
        console.log(`visit "${vertex}"`);
        let neighbors = this.edge[vertex];
        for (let i = 0; i < neighbors.length; i++) {
          if (!this.visited[neighbors[i]]) {
            distance[neighbors[i]] = distance[vertex] + 1;
            pre_visit[neighbors[i]] = vertex;
            queue.enqueue(neighbors[i]);
          }
        }
      }
    
      return { distance, pre_visit };
    };
    ```
    
- print (출력)
    
    ```jsx
    let graph = new Graph();
    let vertices = ["A", "B", "C", "D", "E", "F", "G ", "H", "I"];
    
    for (let i = 0; i < vertices.length; i++) {
      graph.addVertex(vertices[i]);
    }
    graph.addEdge("A", "B");
    graph.addEdge("A", "C");
    graph.addEdge("A", "D");
    graph.addEdge("C", "G");
    graph.addEdge("D", "G");
    graph.addEdge("D", "H");
    graph.addEdge("B", "E");
    graph.addEdge("B", "F");
    graph.addEdge("E", "I");
    graph.print();
    console.log("");
    console.log(graph._bfsShortestPath("A"));
    ```
    
- _from_to_path() : from 정점에서 to 정점으로 최단 경로 출력
    
    ```jsx
    Graph.prototype._from_to_path = function(pre_visit, from, to) {
      let stack = new Stack();
      for (let v = to; v !== from; v = pre_visit[v]) {
        stack.push(v);
      }
      stack.push(from);
    
      while (!stack.isEmpty()) {
        let v = stack.pop();
        process.stdout.write(`${v} -> `);
      }
      console.log("end");
    };
    ```
    
- shortestPath() : 다른 정점 간 최단 경로 탐색
    
    ```jsx
    Graph.prototype.shortestPath = function(startVertex) {
      let result = this._bfsShortestPath(startVertex);
      console.log(result.distance);
      console.log(result.pre_visit);
    
      for (let vertex in this.edge) {
        if (vertex === startVertex) continue;
        this._from_to_path(result.pre_visit, startVertex, vertex);
      }
    };
    ```
    
- print (출력)
    
    ```jsx
    let graph = new Graph();
    let vertices = ["A", "B", "C", "D", "E", "F", "G ", "H", "I"];
    
    for (let i = 0; i < vertices.length; i++) {
      graph.addVertex(vertices[i]);
    }
    graph.addEdge("A", "B");
    graph.addEdge("A", "C");
    graph.addEdge("A", "D");
    graph.addEdge("C", "G");
    graph.addEdge("D", "G");
    graph.addEdge("D", "H");
    graph.addEdge("B", "E");
    graph.addEdge("B", "F");
    graph.addEdge("E", "I");
    graph.print();
    console.log("");
    graph.shortestPath("A");
    ```
    

# 비선형 문제풀이

1. 후위 순회
    
    ```jsx
    // 트리가 주어졌을 때, 후위 순회하며 방문했던 노드를 산출해주는 프로그램을 작성
    // 입력은 노드가 추가되는 순번대로 명시된 문자열이 주어지며, 
    // 트리를 만들어 갈 때 작은 값은 왼쪽으로 큰 값은 오른쪽으로 붙여가며 만든다. 
    // 왼쪽 → 오른쪽 → 루트순으로 후위 순회하며 방문한 노드를 배열에 저장하고 그 결과를 반환한다.
    
    function Node(value) {
      this.value = value;
      this.left = null;
      this.right = null;
    }
    
    function BinaryTree() {
      this.root = null;
    }
    BinaryTree.prototype._insertNode = function(node, value) {
      if (node === null) {
        node = new Node(value);
      } else if (value < node.value) {
        node.left = this._insertNode(node.left, value);
      } else if (value >= node.value) {
        node.right = this._insertNode(node.right, value);
      }
      return node;
    };
    
    BinaryTree.prototype.insert = function(value) {
      this.root = this._insertNode(this.root, value);
    };
    
    BinaryTree.prototype.postOrderTraverse = function(node, array) {
      if (node === null) {
        return;
      }
      this.postOrderTraverse(node.left, array);
      this.postOrderTraverse(node.right, array);
      array.push(node.value);
    };
    
    function answer(str) {
      let result = [];
      let tree = new BinaryTree();
      for (let i = 0; i < str.length; i++) {
        tree.insert(str[i]);
      }
      tree.postOrderTraverse(tree.root, result);
      return result;
    }
    
    /* main code */
    let input = [
      // TC: 1 
      "ABC",
      // TC: 2 
      "FBADCEGIH",
      // TC: 3 
      "CBAEDFG",
    ];
    
    for (let i = 0; i < input.length; i++) {
      process.stdout.write(`#${i + 1} `);
      console.log(answer(input[i]));
    }
    ```
    
2. 바이러스
    
    ```jsx
    // 최근 웜 바이러스가 네트워크를 통해 전파되고 있는데, 한 컴퓨터라도 이 바이러스에 걸리면 컴퓨터와 연결되어 있는 모든 컴퓨터는 바이러스에 걸리게 된다. 
    // 현재 PC에 설정된 네트워크 기준으로, 한대의 PC에 바이러스가 걸렸을 때 총 몇 대의 PC가 바이러스에 걸릴지 계산하는 프로그램을 작성
    // 예를 들어 7번까지의 PC가 있고, 1, 2, 3, 4, 5, 6번 PC는 1번 네트워크, 4, 7번 PC는 2번 네트워크로 구성되어 있을 때, 1번 PC가 바이러스에 걸리면 총 5대의 PC가 바이러스에 걸리게 된다.
    // 입력은 PC의 총 대수와, PC와 PC가 연결된 네트워크 정보가 배열로 입력된다. 
    // 웜 바이러스에 감염된 PC는 무조건 1번으로 고정될 때, 바이러스에 걸리는 총 PC의 대수를 계산하여 반환하시오.
    
    function Graph() {
      this.edge = {};
      this.visited = {};
    }
    
    Graph.prototype.addVertex = function(v) {
      this.edge[v] = [];
      this.visited[v] = false;
    };
    
    Graph.prototype.addEdge = function(v1, v2) {
      this.edge[v2].push(v1);
      this.edge[v1].push(v2);
    };
    
    Graph.prototype.dfs = function(vertex) {
      if (this.visited[vertex]) return;
      this.visited[vertex] = true;
      let neighbors = this.edge[vertex];
      for (let i = 0; i < neighbors.length; i++) {
        this.dfs(neighbors[i]);
      }
    };
    
    function answer(v, e_list) {
      let result = 0;
      let g = new Graph();
      for (let i = 1; i <= v; i++) {
        g.addVertex(i);
      }
      for (let i = 0; i < e_list.length; i++) {
        let e = e_list[i];
        g.addEdge(e[0], e[1]);
      }
      g.dfs(1);
      for (let vertex in g.visited) {
        result += g.visited[vertex] ? 1 : 0;
      }
      return result;
    }
    
    /* main code */
    let input = [
      // TC: 1
      [
        7,
        [
          [1, 2],
          [2, 3],
          [1, 5],
          [1, 5],
          [5, 2],
          [5, 6],
          [4, 7],
        ],
      ],
      // TC: 2
      [
        10,
        [
          [8, 6],
          [5, 7],
          [9, 10],
          [7, 4],
          [1, 8],
          [5, 10],
          [7, 2],
        ],
      ],
      // TC: 3
      [
        10,
        [
          [6, 9],
          [9, 4],
          [4, 8],
          [9, 7],
          [6, 8],
          [10, 1],
          [10, 9],
        ],
      ],
    ];
    
    for (let i = 0; i < input.length; i++) {
      process.stdout.write(`#${i + 1} `);
      console.log(answer(input[i][0], input[i][1]));
    }
    ```
    

1. 미로 찾기
    
    ```jsx
    // 친구가 제주도 미로 공원에서 들어갔는데 1시간째 못 빠져 나오고 있다.
    // 친구를 도와 최단거리로 미로를 빠져나오는 경로를 구하는 프로그램을 작성
    // 미로 공원은 정사각형 형태이며, 길 0과 벽 1로 이루어진 X축 문자열 정보가 Y축 개수만큼 주어진다.
    // 정사각형으로 이루어진 2차원 미로 지도의 입구는 왼쪽 하단이고, 출구는 오른쪽 상단이다.
    // 최단 경로로 입구에서 출구를 나갈 때 거쳐야 하는 길의 개수를 반환하시오.
    // 만약 출구로 갈 수 있는 길이 없다면 -1을 반환한다.
    
    function Node(x, y, c) {
      this.x = x;
      this.y = y;
      this.c = c;
    }
    
    function Queue() {
      this.array = [];
    }
    Queue.prototype.enqueue = function(element) {
      this.array.push(element);
    };
    Queue.prototype.dequeue = function() {
      return this.array.shift();
    };
    Queue.prototype.isEmpty = function() {
      return this.array.length === 0;
    };
    
    function answer(input) {
      let result = -1;
      let size = input.length;
      let dir = [
        [1, 0],
        [0, 1],
        [-1, 0],
        [0, -1],
      ];
      let map = [];
    
      for (let i = 0; i < size; i++) {
        map[i] = [];
        for (let j = 0; j < size; j++) map[i][j] = Number(input[i][j]);
      }
      let s = [0, size - 1];
      let e = [size - 1, 0];
      let q = new Queue();
      q.enqueue(new Node(s[0], s[1], 1));
    
      while (!q.isEmpty()) {
        let v = q.dequeue();
        if (v.x < 0 || v.y < 0 || v.x >= size || v.y >= size) continue;
        if (map[v.y][v.x]) continue;
        if (v.x == e[0] && v.y == e[1]) {
          result = v.c;
          break;
        }
        map[v.y][v.x] = 1;
        for (let i = 0; i < dir.length; i++)
          q.enqueue(new Node(v.x + dir[i][0], v.y + dir[i][1], v.c + 1));
      }
      return result;
    }
    
    /* main code */
    let input = [
      // TC: 1
      ["00110", "00010", "00110", "00000", "01011"],
    
      // TC: 2
      ["00110", "00010", "00110", "00010", "01011"],
    
      // TC: 3
      [
        "1111111100",
        "1111111101",
        "1111111101",
        "1000111101",
        "1010111101",
        "1010011101",
        "1011011101",
        "1011011101",
        "1011000001",
        "0011111111",
      ],
    ];
    for (let i = 0; i < input.length; i++) {
      process.stdout.write(`#${i + 1} `);
      console.log(answer(input[i]));
    }
    ```
