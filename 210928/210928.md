### 콜백함수(Callback Function)

- 콜백함수는 다른 함수의 매개변수로 전달되어 수행되어지는 함수
- 고차함수(Higher-order Function)란 매개 변수를 통해 함수를 받아 호출하는 함수

![callback_func](https://user-images.githubusercontent.com/88661435/135024631-03287069-554a-419c-97fe-ac3b69e520b8.png)

```jsx
// 콜백 함수 예제 : 계산기
function add(x, y) {
  return x + y;
}

function sub(x, y) {
  return x - y;
}

function mul(x, y) {
  return x * y;
}

function div(x, y) {
  return x / y;
}

function calculator(callback, x, y) {
  return callback(x, y);
}

console.log(calculator(add, 7, 3));
console.log(calculator(sub, 7, 3));
console.log(calculator(mul, 7, 3));
console.log(calculator(div, 7, 3));
```

### call by *

1. **call by value**
    - 값에 의한 복사로 함수 내에서 매개 변수 값을 변경시켜도 영향이 미치지 않음
    - **원시타입(primitive type)**을 매개 변수로 넘겼을 때 발생

    ```jsx
    let a = 1;
    let add = function (b) {
    	b = b + 1; //callee
    }
    add(a); //caller
    console.log(a); //output : 1
    ```

    > b = a = 1이기 때문에 b에는 1값이 들어간다. 이때 값에 의한 복사가 실행되며, b라는 변수와 a 변수는 다른 변수이며 값만 복사 되었기 때문에 b에 어떠한 연산을 실행해도 a에는 영향을 미치지 않는다.

1. **call by reference**
    - 주소에 대한 복사로 함수 내에서 매개 변수 내 값을 변경시키면 원본 데이터에도 영향을 받음
    - **객체 타입(object type)**을 배개 변수로 넘겼을 때 발생

    ```jsx
    let a = { v: 1 };
    let add = function (b) {
    	b.v = b.v + 1; //callee
    }
    add(a); //caller
    console.log(a.v); //output : 2
    ```

    > 객체는 별도의 주소값을 갖고 있으므로, 객체를 넘길 경우 주소값이 복사된다. 따라서 b = a의 경우 a의 주소값이 복사되므로, 같은 주소 값을 가지고 있기 때문에 b에서 변경된 값이 a 객체에도 영향을 미친다.

### 함수 관련 연습 문제

```jsx
// 두 정수를 입력 받아 가장 큰 값을 출력해주는 함수 작성
function MAX(x, y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
  // return x > y ? x : y;
}

console.log(MAX(0, 3));
console.log(MAX(-1, 5));
console.log(MAX(100, 7));
```

## Method

### 함수의 표현

```jsx
// 함수 선언식
function add_1(x, y) {
  return x + y;
}

// 함수 표현식
const add_2 = function (x, y) {
  return x + y;
}

// 화살표 함수
const add_3 = (x, y) => x + y;

const add_4 = add_1; //함수도 변수에 넣어서 사용이 가능

console.log(add_4(1, 3))
console.log(add_1 === add_2); //false : 메모리 주소가 다름
console.log(add_1 === add_4); //true : 메모리 주소를 그대로 복사했으므로 같음

// 객체에 대한 상세 내용 보기
console.log(Object.getOwnPropertyDescriptors(add_1));
console.log(Object.getOwnPropertyDescriptors(add_2));
console.log(Object.getOwnPropertyDescriptors(add_3));
console.log(Object.getOwnPropertyDescriptors(add_4));
```

### 함수 저장

- 배열의 요소(element) 혹은 객체의 속성(property)에 함수를 정의하여 저장 가능

    ```jsx
    let list = [
      "ryo",
      20,
      function hello_func() {
        console.log("hello");
      }
    ];

    let obj = {
      name: "ryo",
      age: 20,
      hello_func() {
        console.log("hello");
      }
    };

    function hello_func() {
      console.log("hello!");
    }

    hello_func();
    obj.hello_func();
    list[2]();

    console.log(typeof hello_func);
    console.log(typeof obj.hello_func);
    console.log(typeof list[2]);

    // output
    hello!
    hello
    hello
    function
    function
    function
    ```

### method

- 객체에 저장된 값이 함수인 경우, 이를 메서드라고 부른다.
  ![method](https://user-images.githubusercontent.com/88661435/135024700-bea955b8-30ce-4420-a7e3-43bac0ed200b.png)

### this

- 메서드에서 객체 내부 속성(property) 값을 접근할 수 있는 지시자
  ![this](https://user-images.githubusercontent.com/88661435/135024728-b260aff4-1d26-4ff9-bec0-cf2491345d91.png)

- **객체별로 동일한 속성들을 갖고 있지만, 데이터를 다르게 핸들링할 수 있는 것이 OOP의 장점**

    ```jsx
    let user = { name: "john" };
    let admin = { name: "admin" };

    function hello_func() {
      console.log("Hello " + this.name);
    }

    // 객체의 함수로 들어감
    user.func = hello_func;
    admin.func = hello_func;

    user.func();
    admin.func();

    user["func"]();
    admin["func"]();

    //output
    Hello john
    Hello admin
    Hello john
    Hello admin
    ```

## Number

![number](https://user-images.githubusercontent.com/88661435/135024762-971e8623-c25b-4a50-bb5a-1dfe81033801.png)

1. 지수/진법
- 지수 표기법(Exponential notation)
    - 아주 큰 숫자나 아주 작은 숫자를 표기하기 위해 지수 표기법(e)으로 0의 개수를 대체 표기 가능

    ```jsx
    let billion_1 = 1000000000 //10억
    let billion_2 = 1e9; //1 + 0 9개
    let us = 1e-6; // micro sec, 왼쪽으로 6번 소수점 이동

    console.log(billion_1);
    console.log(billion_2);
    console.log(us);

    //output
    1000000000
    1000000000
    0.000001
    ```

- 진법 표기(Base N)
    - 진법 표기를 지원하기 위해 0x(16진수), 0o(8진수), 0b(2진수)로 N진수 표기 가능

    ```jsx
    console.log(0x0f);
    console.log(0o17);
    console.log(0b1111);

    //output
    15
    15
    15
    ```

2. Number 상수 값
    ![number_const](https://user-images.githubusercontent.com/88661435/135024789-7d09c548-ed37-4757-b14d-103c220b5e99.png)
