# 2021.10.22
알고리즘 로직을 구성할 때, 반드시 복잡도를 고려해야한다.
복잡도는 시간 복잡도와 공간 복잡도로 나뉘는데 이는 효율성에 해당되고 메모리에 직결되기 때문이다.

먼저 시간 복잡도는 입력 크기의 값에 대해 단위 연산을 몇 번 수행하는지 계산하여 알고리즘의 수행시간을 평가하는 방법으로 알고리즘의 시간 효율성을 의미한다.
그리고 공간 복잡도는 알고리즘의 공간(메모) 효율성을 의미한다.

이런 알고리즘의 효율성을 표기해주는 방법이 있는데 Big-O 표기법이다.
- 3가지 점근적 표현법
    - O(빅오) : **최악의 상황**을 고려하여 성능 측정 결과 표현
    - Θ(세타) : **평균**적인 경우에서의 성능 측정 결과 표현
    - Ω(오메가) : **최선의 상황**일 때의 성능 측정 결과 표현

### 빅오 표기법 예제

1. O(1)

```jsx
function big_o(n) {
	let sum = 0;  => 1회
	sum = n * 2;  => 1회
		return sum; => 1회
}

3 => O(1)
```

1. O(N)

```jsx
function big_o(arr, n) {
	let sum = 0;  => 1회
	for (let i = 0; i < n; i++) {
			sum += arr[i];           => n회
	}

		return sum; => 1회
}

n+2 => O(N)
```

1. O(N^2)

```jsx
function big_o(arr, n) {
	let sum = 0;  => 1회
	for (let i = 0; i < n; i++) {
		for (let j = 0; j < n; j++) {
			sum += arr[i][j];           => n * n = n^2
		}
	}

		return sum; => 1회
}

n^2 + 2 => O(N^2)
```

1. O(logN)

```jsx
function big_o(n) {
	let sum = 0;  => 1회
	for (let i = 0; i < n; i *= 2) {
		sum += 2;   => n / 2회
	}

		return sum; => 1회
}

n/2 + 2 => O(logN)
```

<hr>

어떤 사건 혹은 일이 일어날 수 있는 경우의 가짓수를 수로 표현하는 것을 '경우의 수'라고 한다.
이때, 완전 탐색으로 경우의 수를 푸는 알고리즘이 있는데 아래와 같다.
- 완전탐색으로 경우의 수를 푸는 알고리즘
    - 순열 : 서로 다른 n개의 원소 중에서 r를 중복 없이 골라 **순서에 상관 있게** 나열하는 경우의 수(nPr)
    - 조합 : 서로 다른 n개의 원소 중에서 r를 중복 없이 골라 **순서에 상관 없이** 나열하는 경우의 수(nCr)
    - 중복 순열 : 서로 다른 n개의 원소 중에서 r개를 중복 있게 골라 순서에 상관없이 나열하는 경우의 수(nH)

<br>

아래와 같이 3개의 알파벳으로 단어를 만드는 경우의 수를 추출하는 알고리즘을 푸는 경우,
난 평소에 아래와 같이 n중 for문을 이용하여 풀곤 했었다.

```jsx
// 순열 예제 1
// for문 이용하여 3개의 알파벳으로 다양한 경우의 수 추출

let input = ["a", "b", "c"];
let count = 0;

function permutation(arr) {
  // 선택해야 하는 문자가 3개니, 변수도 3개 필요 [i, 0, 0]
  // for i -> 첫 번째 index에 위치시킬 요소
  for (let i = 0; i < arr.length; i++) {
    // for j -> 두 번째 index에 위치 시킬 요소 [i, j, 0]
    for (let j = 0; j < arr.length; j++) {
      if (i == j) continue; // 값이 같으면 건너 뜀
      // for k -> 세 번째 index에 위치 시킬 요소 [i, j, k]
      for (let k = 0; k < arr.length; k++) {
        if (i == k) continue;
        if (j == k) continue;

        console.log(arr[i], arr[j], arr[k]);
        count++;
      }
    }
  }
}

permutation(input);
console.log(count);
```

<br>

그리고 강사님께서는 이런 n중 for문을 재귀 함수를 이용하는 방법으로 바꿈으로써 아래와 같이 복잡도를 확 줄였다.

```jsx
// 순열 예제 2
// 재귀 함수를 이용하여 3개의 알파벳으로 다양한 경우의 수 추출

let input = ["a", "b", "c"]; 
let count = 0;

function permutation(arr, s, r) {  //배열, 시작할 위치 정보, 몇 개를 뽑을지
	// 1. 재귀함수를 멈춰야 할 조건
	if (s == r) { // 목표 인덱스까지 도달했을 때 중지
		count++;
		console.log(arr.join(" ")); 
		return;
	}
	// 2. 재귀를 돌면서 변경되어야 될 부분 (메인 로직)
  // i를 0으로 초기화하면 중복해서 뽑을 수 있으므로, s를 넣어줌으로써 s값이 변하여 선택된 것은 뽑지 않도록 s 대입
  for (let i = s; i < arr.length; i++) {
		[arr[s], arr[i]] = [arr[i], arr[s]]; // swap
		permutation(arr, s + 1, r);
		[arr[s], arr[i]] = [arr[i], arr[s]]; // 원복
	}
}

permutation(input, 0, 2); 
console.log(count);
```

<br>

그런데 나는 재귀함수가 무엇인지는 알겠는데... 막상 내가 직접 코드를 짜보려고 하니 어려웠다. <br>
코드를 보다보니 머리가 복잡해서 손으로 디버깅 하는데도 헷갈려서 이 짧은 코드를 가지고 고민이 많아졌다.
<br>
그러다 한 줄, 한 줄 주석으로 남기면서 디버깅을 해보았다.      

```jsx
      // 1. abc의 경우
      s = 0, r = 2, i = 0, 값 = ["a"]
      s = 1, r = 2, i = 1, 값 = ["a", "b"]
      s = 2, r = 2, 값 = ["a", "b", "c"], count 증가 및 return으로 종료 처리
      원복 arr = ["a", "b", ]

      // 2. acb의 경우
      s = 1, r = 2, i = 2, 값 = ["a", "c", "b"]
      s = 2, r = 2, 값 = ["a", "c", "b"], count 증가 및 return으로 종료 처리
      원복 arr = ["a", "b", "c"]

      // 3. bac의 경우
      s = 0, r = 2, i = 1, 값 = ["b", "a"]
      s = 1, r = 2, i = 1, 값 = ["b", "a"]
      s = 2, r = 2, 값 = ["b", "a", "c"], count 증가 및 return으로 종료 처리
      원복 arr = ["b", "a", "c"]

      // 4. bca의 경우
      s = 1, r = 2, i = 2, 값 = ["b", "c", "a"]
      s = 2, r = 2, 값 = ["b", "c", "a"], count 증가 및 return으로 종료 처리
      원복 arr = ["b", "a", "c"]

      // 5. cba의 경우
      s = 0, r = 2, i = 2, 값 = ["c", "a", "b"]
      s = 1, r = 2, i = 2, 값 = ["c", "b", "a"]
      s = 2, r = 2, 값 = ["c", "b", "a"], count 증가 및 return으로 종료 처리
      원복 arr = ["c", "a", "b"]

      // 6. cab의 경우
      s = 2, r = 2, i = 2, 값 = ["c", "a", "b"], count 증가 및 return으로 종료 처리
```

위처럼 한 줄, 한 줄 작성하니 좀 이해가 됐다. <br>
재귀 함수를 사용하여 함수가 종료가 될 시점을 명시하고 함수가 종료된 뒤 값을 증가시켜 그 다음 배열 값을 비교함으로써 코드가 확실히 간결해졌다. <br>
이해가 되고 이렇게 보니 가독성도 좋고 한 눈에 코드가 들어오는 것 같다. <br>
많은 연습과 노력이 필요할 것 같다.
